{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ToWords = exports.DefaultToWordsOptions = exports.DefaultConverterOptions = void 0;\nconst en_AE_1 = __importDefault(require(\"./locales/en-AE\"));\nconst en_BD_1 = __importDefault(require(\"./locales/en-BD\"));\nconst en_GH_1 = __importDefault(require(\"./locales/en-GH\"));\nconst en_IE_1 = __importDefault(require(\"./locales/en-IE\"));\nconst en_IN_1 = __importDefault(require(\"./locales/en-IN\"));\nconst en_MM_1 = __importDefault(require(\"./locales/en-MM\"));\nconst en_MU_1 = __importDefault(require(\"./locales/en-MU\"));\nconst en_NG_1 = __importDefault(require(\"./locales/en-NG\"));\nconst en_NP_1 = __importDefault(require(\"./locales/en-NP\"));\nconst en_US_1 = __importDefault(require(\"./locales/en-US\"));\nconst en_GB_1 = __importDefault(require(\"./locales/en-GB\"));\nconst en_PH_1 = __importDefault(require(\"./locales/en-PH\"));\nconst fa_IR_1 = __importDefault(require(\"./locales/fa-IR\"));\nconst fr_BE_1 = __importDefault(require(\"./locales/fr-BE\"));\nconst fr_FR_1 = __importDefault(require(\"./locales/fr-FR\"));\nconst gu_IN_1 = __importDefault(require(\"./locales/gu-IN\"));\nconst hi_IN_1 = __importDefault(require(\"./locales/hi-IN\"));\nconst mr_IN_1 = __importDefault(require(\"./locales/mr-IN\"));\nconst pt_BR_1 = __importDefault(require(\"./locales/pt-BR\"));\nconst tr_TR_1 = __importDefault(require(\"./locales/tr-TR\"));\nconst nl_SR_1 = __importDefault(require(\"./locales/nl-SR\"));\nconst ee_EE_1 = __importDefault(require(\"./locales/ee-EE\"));\nexports.DefaultConverterOptions = {\n  currency: false,\n  ignoreDecimal: false,\n  ignoreZeroCurrency: false,\n  doNotAddOnly: false\n};\nexports.DefaultToWordsOptions = {\n  localeCode: 'en-IN',\n  converterOptions: exports.DefaultConverterOptions\n};\nclass ToWords {\n  constructor() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    this.options = {};\n    this.locale = undefined;\n    this.options = Object.assign({}, exports.DefaultToWordsOptions, options);\n  }\n  getLocaleClass() {\n    /* eslint-disable @typescript-eslint/no-var-requires */\n    switch (this.options.localeCode) {\n      case 'ee-EE':\n        return ee_EE_1.default;\n      case 'en-AE':\n        return en_AE_1.default;\n      case 'en-BD':\n        return en_BD_1.default;\n      case 'en-GH':\n        return en_GH_1.default;\n      case 'en-IE':\n        return en_IE_1.default;\n      case 'en-IN':\n        return en_IN_1.default;\n      case 'en-MM':\n        return en_MM_1.default;\n      case 'en-MU':\n        return en_MU_1.default;\n      case 'en-NG':\n        return en_NG_1.default;\n      case 'en-NP':\n        return en_NP_1.default;\n      case 'en-US':\n        return en_US_1.default;\n      case 'en-GB':\n        return en_GB_1.default;\n      case 'en-PH':\n        return en_PH_1.default;\n      case 'fa-IR':\n        return fa_IR_1.default;\n      case 'fr-BE':\n        return fr_BE_1.default;\n      case 'fr-FR':\n        return fr_FR_1.default;\n      case 'gu-IN':\n        return gu_IN_1.default;\n      case 'hi-IN':\n        return hi_IN_1.default;\n      case 'mr-IN':\n        return mr_IN_1.default;\n      case 'pt-BR':\n        return pt_BR_1.default;\n      case 'tr-TR':\n        return tr_TR_1.default;\n      case 'nl-SR':\n        return nl_SR_1.default;\n    }\n    /* eslint-enable @typescript-eslint/no-var-requires */\n    throw new Error(\"Unknown Locale \\\"\".concat(this.options.localeCode, \"\\\"\"));\n  }\n  getLocale() {\n    if (this.locale === undefined) {\n      const LocaleClass = this.getLocaleClass();\n      this.locale = new LocaleClass();\n    }\n    return this.locale;\n  }\n  convert(number) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    options = Object.assign({}, this.options.converterOptions, options);\n    if (!this.isValidNumber(number)) {\n      throw new Error(\"Invalid Number \\\"\".concat(number, \"\\\"\"));\n    }\n    if (options.ignoreDecimal) {\n      number = Number.parseInt(number.toString());\n    }\n    let words = [];\n    if (options.currency) {\n      words = this.convertCurrency(number, options);\n    } else {\n      words = this.convertNumber(number);\n    }\n    return words.join(' ');\n  }\n  convertNumber(number) {\n    var _a, _b, _c;\n    const locale = this.getLocale();\n    const isNegativeNumber = number < 0;\n    if (isNegativeNumber) {\n      number = Math.abs(number);\n    }\n    const split = number.toString().split('.');\n    const ignoreZero = this.isNumberZero(number) && locale.config.ignoreZeroInDecimals;\n    let words = this.convertInternal(Number(split[0]));\n    const isFloat = this.isFloat(number);\n    if (isFloat && ignoreZero) {\n      words = [];\n    }\n    const wordsWithDecimal = [];\n    if (isFloat) {\n      if (!ignoreZero) {\n        wordsWithDecimal.push(locale.config.texts.point);\n      }\n      if (split[1].startsWith('0') && !((_a = locale.config) === null || _a === void 0 ? void 0 : _a.decimalLengthWordMapping)) {\n        const zeroWords = [];\n        for (const num of split[1]) {\n          zeroWords.push(...this.convertInternal(Number(num)));\n        }\n        wordsWithDecimal.push(...zeroWords);\n      } else {\n        wordsWithDecimal.push(...this.convertInternal(Number(split[1])));\n        const decimalLengthWord = (_c = (_b = locale.config) === null || _b === void 0 ? void 0 : _b.decimalLengthWordMapping) === null || _c === void 0 ? void 0 : _c[split[1].length];\n        if (decimalLengthWord) {\n          wordsWithDecimal.push(decimalLengthWord);\n        }\n      }\n    }\n    const isEmpty = words.length <= 0;\n    if (!isEmpty && isNegativeNumber) {\n      words.unshift(locale.config.texts.minus);\n    }\n    words.push(...wordsWithDecimal);\n    return words;\n  }\n  convertCurrency(number) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var _a, _b, _c, _d;\n    const locale = this.getLocale();\n    const currencyOptions = (_a = options.currencyOptions) !== null && _a !== void 0 ? _a : locale.config.currency;\n    const isNegativeNumber = number < 0;\n    if (isNegativeNumber) {\n      number = Math.abs(number);\n    }\n    number = this.toFixed(number);\n    // Extra check for isFloat to overcome 1.999 rounding off to 2\n    const split = number.toString().split('.');\n    let words = [...this.convertInternal(Number(split[0]))];\n    // Determine if the main currency should be in singular form\n    // e.g. 1 Dollar Only instead of 1 Dollars Only\n    if (Number(split[0]) === 1 && currencyOptions.singular) {\n      words.push(currencyOptions.name);\n    } else if (currencyOptions.plural) {\n      words.push(currencyOptions.plural);\n    }\n    const ignoreZero = this.isNumberZero(number) && (options.ignoreZeroCurrency || ((_b = locale.config) === null || _b === void 0 ? void 0 : _b.ignoreZeroInDecimals) && number !== 0);\n    if (ignoreZero) {\n      words = [];\n    }\n    const wordsWithDecimal = [];\n    const isFloat = this.isFloat(number);\n    if (isFloat) {\n      if (!ignoreZero) {\n        wordsWithDecimal.push(locale.config.texts.and);\n      }\n      const decimalPart = Number(split[1]) * (!locale.config.decimalLengthWordMapping ? Math.pow(10, 2 - split[1].length) : 1);\n      wordsWithDecimal.push(...this.convertInternal(decimalPart));\n      const decimalLengthWord = (_d = (_c = locale.config) === null || _c === void 0 ? void 0 : _c.decimalLengthWordMapping) === null || _d === void 0 ? void 0 : _d[split[1].length];\n      if (decimalLengthWord === null || decimalLengthWord === void 0 ? void 0 : decimalLengthWord.length) {\n        wordsWithDecimal.push(decimalLengthWord);\n      }\n      // Determine if the fractional unit should be in singular form\n      // e.g. 1 Dollar and 1 Cent Only instead of 1 Dollar and 1 Cents Only\n      if (decimalPart === 1 && currencyOptions.fractionalUnit.singular) {\n        wordsWithDecimal.push(currencyOptions.fractionalUnit.singular);\n      } else {\n        wordsWithDecimal.push(currencyOptions.fractionalUnit.plural);\n      }\n    } else if (locale.config.decimalLengthWordMapping && words.length) {\n      wordsWithDecimal.push(currencyOptions.fractionalUnit.plural);\n    }\n    const isEmpty = words.length <= 0 && wordsWithDecimal.length <= 0;\n    if (!isEmpty && isNegativeNumber) {\n      words.unshift(locale.config.texts.minus);\n    }\n    if (!isEmpty && locale.config.texts.only && !options.doNotAddOnly && !locale.config.onlyInFront) {\n      wordsWithDecimal.push(locale.config.texts.only);\n    }\n    if (wordsWithDecimal.length) {\n      words.push(...wordsWithDecimal);\n    }\n    if (!isEmpty && !options.doNotAddOnly && locale.config.onlyInFront) {\n      words.splice(0, 0, locale.config.texts.only);\n    }\n    return words;\n  }\n  convertInternal(number) {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o;\n    const locale = this.getLocale();\n    if (locale.config.exactWordsMapping) {\n      const exactMatch = (_b = (_a = locale.config) === null || _a === void 0 ? void 0 : _a.exactWordsMapping) === null || _b === void 0 ? void 0 : _b.find(elem => {\n        return number === elem.number;\n      });\n      if (exactMatch) {\n        return [exactMatch.value];\n      }\n    }\n    const match = locale.config.numberWordsMapping.find(elem => {\n      return number >= elem.number;\n    });\n    const words = [];\n    if (number <= 100 || number < 1000 && locale.config.namedLessThan1000) {\n      words.push(match.value);\n      number -= match.number;\n      if (number > 0) {\n        if ((_d = (_c = locale.config) === null || _c === void 0 ? void 0 : _c.splitWord) === null || _d === void 0 ? void 0 : _d.length) {\n          words.push(locale.config.splitWord);\n        }\n        words.push(...this.convertInternal(number));\n      }\n      return words;\n    }\n    const quotient = Math.floor(number / match.number);\n    const remainder = number % match.number;\n    let matchValue = match.value;\n    if (quotient > 1 && ((_f = (_e = locale.config) === null || _e === void 0 ? void 0 : _e.pluralWords) === null || _f === void 0 ? void 0 : _f.find(word => word === match.value)) && ((_g = locale.config) === null || _g === void 0 ? void 0 : _g.pluralMark)) {\n      matchValue += locale.config.pluralMark;\n    }\n    if (quotient === 1 && ((_j = (_h = locale.config) === null || _h === void 0 ? void 0 : _h.ignoreOneForWords) === null || _j === void 0 ? void 0 : _j.includes(matchValue))) {\n      words.push(matchValue);\n    } else {\n      words.push(...this.convertInternal(quotient), matchValue);\n    }\n    if (remainder > 0) {\n      if ((_l = (_k = locale.config) === null || _k === void 0 ? void 0 : _k.splitWord) === null || _l === void 0 ? void 0 : _l.length) {\n        if (!((_o = (_m = locale.config) === null || _m === void 0 ? void 0 : _m.noSplitWordAfter) === null || _o === void 0 ? void 0 : _o.find(word => word === match.value))) {\n          words.push(locale.config.splitWord);\n        }\n      }\n      words.push(...this.convertInternal(remainder));\n    }\n    return words;\n  }\n  toFixed(number) {\n    let precision = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;\n    return Number(Number(number).toFixed(precision));\n  }\n  isFloat(number) {\n    return Number(number) === number && number % 1 !== 0;\n  }\n  isValidNumber(number) {\n    return !isNaN(parseFloat(number)) && isFinite(number);\n  }\n  isNumberZero(number) {\n    return number >= 0 && number < 1;\n  }\n}\nexports.ToWords = ToWords;","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}